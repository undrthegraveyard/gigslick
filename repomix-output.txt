This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-04T03:48:00.562Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
client/
  src/
    components/
      ChatInput/
        ChatInput.tsx
      FileUpload/
        FileUpload.tsx
      Message/
        Message.tsx
    config/
      constants.ts
      env.ts
    hooks/
      useChat.ts
    navigation/
      StackNavigator.tsx
    screens/
      ChatScreen.tsx
      HomeScreen.tsx
    services/
      api/
        apiService.ts
      file/
        fileService.ts
    types/
      message.ts
    utils/
      errorHandler.ts
    app.json
    App.tsx
  .gitignore
  babel.config.js
  package.json
  tailwind.config.js
  tsconfig.json
server/
  config/
    constants.js
    openai.js
  middleware/
    errorHandler.js
    upload.js
    validate.js
  routes/
    jobRoutes.js
    resumeRoutes.js
  services/
    jobService.js
    logService.js
    resumeService.js
  utils/
    asyncHandler.js
    error.js
  .gitignore
  package.json
  server.js
README.md

================================================================
Repository Files
================================================================

================
File: client/src/components/ChatInput/ChatInput.tsx
================
import React, { useState } from 'react';
import { View, TextInput, TouchableOpacity, KeyboardAvoidingView, Platform } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import type { DocumentPickerAsset } from 'expo-document-picker';
import { FileUploadButton } from '../FileUpload/FileUpload';

interface ChatInputBarProps {
  onSendMessage: (text: string) => Promise<void> | void;
  onFileSelect: (file: DocumentPickerAsset) => Promise<void>;
  onError: (error: string) => void;
  disabled?: boolean;
}

export const ChatInputBar: React.FC<ChatInputBarProps> = ({
  onSendMessage,
  onFileSelect,
  onError,
  disabled = false
}) => {
  const [inputText, setInputText] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);

  const handleSend = async () => {
    if (disabled || isSubmitting || !inputText.trim()) return;

    try {
      setIsSubmitting(true);
      await onSendMessage(inputText.trim());
      setInputText('');
    } catch (error) {
      onError(error instanceof Error ? error.message : 'Failed to send message');
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <KeyboardAvoidingView
      behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
      className="absolute left-0 right-0 bottom-0 bg-white border-t border-gray-200 z-50"
    >
      <View className="flex-row items-center p-2 min-h-[60px] bg-white">
        <FileUploadButton 
          onFileSelect={onFileSelect} 
          onError={onError}
          disabled={disabled} 
        />
        <TextInput
          className="flex-1 mx-2 px-3 py-2 max-h-[100px] bg-gray-100 rounded-full"
          value={inputText}
          onChangeText={setInputText}
          placeholder="Enter unstructured job description..."
          multiline
          editable={!disabled}
          onSubmitEditing={handleSend}
        />
        <TouchableOpacity 
          className={`p-2 ${(disabled || !inputText.trim()) ? 'opacity-50' : 'active:opacity-70'}`}
          onPress={handleSend}
          disabled={disabled || !inputText.trim() || isSubmitting}
        >
          <Ionicons 
            name="send" 
            size={24} 
            color={disabled ? '#999' : '#007AFF'} 
          />
        </TouchableOpacity>
      </View>
    </KeyboardAvoidingView>
  );
};

================
File: client/src/components/FileUpload/FileUpload.tsx
================
import React, { useState } from 'react';
import { TouchableOpacity, ActivityIndicator } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import type { DocumentPickerAsset } from 'expo-document-picker';
import { fileHandler, FileError } from '@/services/file/fileService';
import type { FileHandler, ErrorHandler } from '@/types/message';

interface FileUploadButtonProps {
  onFileSelect: FileHandler;
  onError: ErrorHandler;
  disabled?: boolean;
  loading?: boolean;
}

export const FileUploadButton: React.FC<FileUploadButtonProps> = ({
  onFileSelect,
  onError,
  disabled = false,
  loading = false
}) => {
  const [isUploading, setIsUploading] = useState(false);

  const handlePress = async () => {
    if (disabled || isUploading) return;

    try {
      setIsUploading(true);
      const file = await fileHandler.pickDocument();
      
      if (file) {
        await onFileSelect(file);
      }
    } catch (error) {
      if (error instanceof FileError) {
        onError(error.message);
      } else {
        onError('Failed to pick or upload document');
      }
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <TouchableOpacity 
      className={`p-2 ${disabled ? 'opacity-50' : 'active:opacity-70'}`}
      onPress={handlePress}
      disabled={disabled || isUploading}
    >
      {isUploading ? (
        <ActivityIndicator size="small" color="#007AFF" />
      ) : (
        <Ionicons 
          name="add" 
          size={28} 
          color={disabled ? '#A0AEC0' : '#007AFF'} 
        />
      )}
    </TouchableOpacity>
  );
};

================
File: client/src/components/Message/Message.tsx
================
import React from 'react';
import { View, Text, TouchableOpacity, ActivityIndicator } from 'react-native';
import { Ionicons } from '@expo/vector-icons';
import type { Message, ConfirmationHandler } from '@/types/message';

interface MessageBubbleProps {
  message: Message;
  onConfirm?: ConfirmationHandler;
}

export const MessageBubble: React.FC<MessageBubbleProps> = ({ message, onConfirm }) => {
  const isUserMessage = message.sender === 'Me';
  const baseMessageClass = "rounded-xl p-3 mb-2";
  const messageTypeClass = isUserMessage
    ? "bg-blue-500 text-white self-end ml-[20%]"
    : "bg-white text-gray-900 self-start mr-[20%] shadow-sm";

  const handleConfirm = (confirmed: boolean) => {
    if (onConfirm && message.structuredText) {
      onConfirm(confirmed, message.structuredText);
    }
  };

  if (message.type === 'confirmation') {
    return (
      <View className={`${baseMessageClass} ${messageTypeClass}`}>
        <Text className="text-base leading-5 mb-3">{message.text}</Text>
        <View className="flex-row justify-end space-x-2">
          <TouchableOpacity
            className="bg-green-500 px-4 py-2 rounded-full"
            onPress={() => handleConfirm(true)}
          >
            <Text className="text-white font-medium">Yes</Text>
          </TouchableOpacity>
          <TouchableOpacity
            className="bg-red-500 px-4 py-2 rounded-full"
            onPress={() => handleConfirm(false)}
          >
            <Text className="text-white font-medium">No</Text>
          </TouchableOpacity>
        </View>
      </View>
    );
  }

  if (!message) return null;

  const renderFilePreview = () => (
    message.file && (
      <View className="flex-row items-center bg-gray-50 rounded-lg p-2 mt-2">
        <Ionicons name="document" size={24} color="#007AFF" />
        <View className="flex-1 ml-2">
          <Text 
            className="font-medium text-sm text-gray-900" 
            numberOfLines={1}
          >
            {message.file.name}
          </Text>
          {message.file.size && (
            <Text className="text-xs text-gray-600">
              {(message.file.size / 1024).toFixed(2)} KB
            </Text>
          )}
        </View>
      </View>
    )
  );

  const renderErrorState = () => (
    message.error && (
      <View className="mt-2">
        <Text className="text-red-500 text-sm mb-1">{message.error}</Text>
        {onRetry && (
          <TouchableOpacity
            className="bg-gray-200 py-1 px-3 rounded-md self-start"
            onPress={onRetry}
            disabled={isRetrying}
          >
            {isRetrying ? (
              <ActivityIndicator size="small" color="#374151" />
            ) : (
              <Text className="text-gray-700">Retry</Text>
            )}
          </TouchableOpacity>
        )}
      </View>
    )
  );

  return (
    <View className={`${baseMessageClass} ${messageTypeClass}`}>
      <Text className={`text-base leading-5 ${isUserMessage ? 'text-white' : 'text-gray-900'}`}>
        {message.text}
      </Text>
      
      {message.type === 'file' && renderFilePreview()}
      {renderErrorState()}
      
      {message.timestamp && (
        <Text className={`text-xs mt-1 ${isUserMessage ? 'text-blue-100' : 'text-gray-500'}`}>
          {new Date(message.timestamp).toLocaleTimeString([], { 
            hour: '2-digit', 
            minute: '2-digit' 
          })}
        </Text>
      )}
    </View>
  );
};

================
File: client/src/config/constants.ts
================
import { ENV } from './env';

export const API_CONFIG = {
  BASE_URL: ENV.API_URL,
  ENDPOINTS: {
    UPLOAD_RESUME: '/api/upload-resume',
    UPDATE_RESUME: '/api/update-resume',
    STRUCTURE_JOB: '/api/structure-job-description',
  },
  TIMEOUT: 15000,
  RETRY_ATTEMPTS: 3,
};

export const FILE_CONFIG = {
  MAX_SIZE: 5 * 1024 * 1024, // 5MB
  ALLOWED_TYPES: ['application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
  ERROR_MESSAGES: {
    SIZE_EXCEEDED: 'File size exceeds 5MB limit',
    INVALID_TYPE: 'Only .docx files are supported',
  },
};

================
File: client/src/config/env.ts
================
export const ENV = {
  API_URL: process.env.EXPO_PUBLIC_API_URL || 'http://localhost:5001',
  ENV: process.env.EXPO_PUBLIC_ENV || 'development',
};

================
File: client/src/hooks/useChat.ts
================
import { useState, useCallback } from 'react';
import { Message, FileUploadResponse } from '@/types/message';
import { chatService } from '@/services/api/apiService';
import { fileHandler } from '@/services/file/fileService';

export const useChat = () => {
  const [messages, setMessages] = useState<Message[]>([
    { 
      id: '1', 
      text: 'Hello! Please upload your resume or enter your unstructured job description.', 
      sender: 'AI' 
    },
  ]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [lastUploadedResume, setLastUploadedResume] = useState<DocumentPicker.DocumentPickerAsset | null>(null);

  const addMessage = useCallback((message: Message) => {
    setMessages(prev => [...prev, message]);
  }, []);

  const handleFileUpload = async (file: DocumentPicker.DocumentPickerAsset) => {
    setLoading(true);
    setError('');
    try {
      const formData = await fileHandler.createFormData(file);
      const response = await chatService.uploadResume(formData);
      
      setLastUploadedResume(file);
      
      addMessage({
        id: Date.now().toString(),
        text: `Resume "${file.name}" uploaded successfully. Please describe your newest job to add to the resume.`,
        sender: 'AI',
        type: 'file',
        file: {
          name: file.name,
          size: file.size,
          type: file.mimeType,
        },
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  const handleResumeUpdate = async (structuredJobDetails: string) => {
    if (!lastUploadedResume) {
      setError('Please upload a resume first');
      return;
    }

    setLoading(true);
    setError('');

    try {
      const formData = await fileHandler.createFormData(lastUploadedResume, {
        structuredJobDetails,
      });

      const result = await chatService.updateResume(formData);

      if (!result.success) {
        throw new Error(result.message || 'Failed to update resume');
      }

      addMessage({
        id: Date.now().toString(),
        text: 'Resume updated successfully! You can download it using the link below.',
        sender: 'AI',
        type: 'file',
        file: {
          name: 'Updated Resume',
          path: result.path,
        },
      });
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to update resume';
      setError(errorMessage);
      addMessage({
        id: Date.now().toString(),
        text: `Error: ${errorMessage}`,
        sender: 'AI',
      });
    } finally {
      setLoading(false);
    }
  };

  const sendMessage = async (text: string) => {
    if (!text.trim()) return;

    addMessage({
      id: Date.now().toString(),
      text,
      sender: 'Me',
    });

    setLoading(true);
    setError('');
    
    try {
      const response = await chatService.structureJobDescription(text);

      // Add AI response
      addMessage({
        id: (Date.now() + 1).toString(),
        text: `Here's the structured job description. Would you like to add this to your resume?\n\n${response.structuredText}`,
        sender: 'AI',
      });
      
      // Add confirmation prompt
      addMessage({
        id: (Date.now() + 2).toString(),
        text: 'Would you like to add this to your resume?',
        sender: 'AI',
        type: 'confirmation',
        structuredText: response.structuredText,
      });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  };

  return {
    messages,
    loading,
    error,
    handleFileUpload,
    handleResumeUpdate,
    sendMessage,
    addMessage,
  };
};

================
File: client/src/navigation/StackNavigator.tsx
================
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import type { RootStackParamList } from '@/types/message';
import HomeScreen from '@/screens/HomeScreen';
import ChatScreen from '@/screens/ChatScreen';

const Stack = createStackNavigator<RootStackParamList>();

export default function StackNavigator() {
  return (
    <NavigationContainer>
      <Stack.Navigator 
        initialRouteName="Home"
        screenOptions={{
          headerStyle: {
            backgroundColor: '#f4511e',
          },
          headerTintColor: '#fff',
          headerTitleStyle: {
            fontWeight: 'bold',
          },
        }}
      >
        <Stack.Screen 
          name="Home" 
          component={HomeScreen} 
          options={{ title: 'Welcome' }}
        />
        <Stack.Screen 
          name="Chat" 
          component={ChatScreen} 
          options={{ title: 'Resume Builder Chat' }}
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
}

================
File: client/src/screens/ChatScreen.tsx
================
import React, { useRef } from 'react';
import {
  View,
  Text,
  ScrollView,
  ActivityIndicator,
} from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Message } from '@/types/message';
import { MessageBubble } from '@/components/Message/Message';
import { ChatInputBar } from '@/components/ChatInput/ChatInput';
import { useChat } from '@/hooks/useChat';

export default function ChatScreen() {
  const { 
    messages, 
    loading, 
    error,
    handleFileUpload,
    handleResumeUpdate,
    sendMessage,
    addMessage
  } = useChat();
  
  const scrollViewRef = useRef<ScrollView>(null);

  const handleConfirmAction = async (confirm: boolean, structuredText?: string) => {
    if (confirm && structuredText) {
      await handleResumeUpdate(structuredText);
    } else {
      // Add decline message through hook
      addMessage({
        id: Date.now().toString(),
        text: 'Okay, the resume will not be updated.',
        sender: 'AI',
      });
    }
  };

  return (
    <SafeAreaView className="flex-1 bg-gray-50">
      {/* Main scrollable content */}
      <View className="flex-1 mb-[60px]">
        <ScrollView
          ref={scrollViewRef}
          className="flex-1"
          contentContainerClassName="p-4 pb-5"
          keyboardShouldPersistTaps="handled"
        >
          {messages.map((message) => (
            <View key={message.id} className="my-1 max-w-[80%]">
              <MessageBubble 
                message={message} 
                onConfirm={handleConfirmAction}
              />
            </View>
          ))}
          
          {loading && (
            <View className="p-5 items-center">
              <ActivityIndicator size="large" color="#007AFF" />
            </View>
          )}
          
          {error ? (
            <Text className="text-red-500 bg-red-50 p-3 rounded-lg my-2 text-center">
              {error}
            </Text>
          ) : null}
        </ScrollView>
      </View>

      {/* Chat Input */}
      <ChatInputBar
        onSendMessage={sendMessage}
        onFileSelect={handleFileUpload}
        onError={(error) => console.error(error)}
      />
    </SafeAreaView>
  );
}

================
File: client/src/screens/HomeScreen.tsx
================
import React from 'react';
import { View, Text, TouchableOpacity } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import type { StackNavigationProp } from '@react-navigation/stack';
import type { RootStackParamList } from '@/types/message';

type HomeScreenProps = {
  navigation: StackNavigationProp<RootStackParamList, 'Home'>;
};

export default function HomeScreen({ navigation }: HomeScreenProps) {
  return (
    <SafeAreaView className="flex-1 bg-white">
      <View className="flex-1 justify-center items-center p-5">
        <Text className="text-3xl font-bold mb-2.5 text-primary">Resume Builder</Text>
        <Text className="text-lg text-center mb-8 text-gray-700">
          Create your professional resume with AI assistance
        </Text>
        <TouchableOpacity
          className="bg-primary px-8 py-4 rounded-full"
          onPress={() => navigation.navigate('Chat')}
        >
          <Text className="text-lg font-bold text-white">Start Building</Text>
        </TouchableOpacity>
      </View>
    </SafeAreaView>
  );
}

================
File: client/src/services/api/apiService.ts
================
import axios from 'axios';
import { API_CONFIG } from '@/config/constants';
import type { FileUploadResponse, JobStructureResponse } from '@/types/message';

class ChatService {
  private api = axios.create({
    baseURL: API_CONFIG.BASE_URL,
    timeout: 10000,
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  });

  async uploadResume(formData: FormData): Promise<FileUploadResponse> {
    try {
      const response = await this.api.post(API_CONFIG.ENDPOINTS.UPLOAD_RESUME, formData);
      return response.data;
    } catch (error) {
      this.handleError(error);
    }
  }

  async updateResume(formData: FormData): Promise<FileUploadResponse> {
    try {
      const response = await this.api.post(API_CONFIG.ENDPOINTS.UPDATE_RESUME, formData);
      return response.data;
    } catch (error) {
      this.handleError(error);
    }
  }

  async structureJobDescription(description: string): Promise<JobStructureResponse> {
    try {
      const response = await this.api.post(API_CONFIG.ENDPOINTS.STRUCTURE_JOB, {
        description,
      }, {
        headers: {
          'Content-Type': 'application/json'
        }
      });
      
      if (!response.data.success) {
        throw new Error(response.data.message || 'Failed to structure job description');
      }
      
      return response.data;
    } catch (error) {
      return this.handleError(error);
    }
  }

  private handleError(error: unknown): never {
    if (axios.isAxiosError(error)) {
      const message = error.response?.data?.message || error.message;
      throw new AppError(message, error.response?.status?.toString());
    }
    throw error;
  }

  private async retryRequest<T>(request: () => Promise<T>, retries = 3): Promise<T> {
    try {
      return await request();
    } catch (error) {
      if (retries > 0) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        return this.retryRequest(request, retries - 1);
      }
      throw error;
    }
  }
}

export const chatService = new ChatService();

================
File: client/src/services/file/fileService.ts
================
import * as DocumentPicker from 'expo-document-picker';
import * as FileSystem from 'expo-file-system';
import { Platform } from 'react-native';

export class FileError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'FileError';
  }
}

export const fileHandler = {
  pickDocument: async () => {
    try {
      const result = await DocumentPicker.getDocumentAsync({
        type: ['application/vnd.openxmlformats-officedocument.wordprocessingml.document'],
      });

      if (result.canceled) {
        return null;
      }

      if (result.assets && result.assets.length > 0) {
        return result.assets[0];
      }

      throw new FileError('No file selected');
    } catch (error) {
      if (error instanceof FileError) {
        throw error;
      }
      throw new FileError('Failed to pick document');
    }
  },

  createFormData: async (
    file: DocumentPicker.DocumentPickerAsset, 
    additionalData?: Record<string, any>
  ): Promise<FormData> => {
    const formData = new FormData();

    try {
      if (!file.uri) {
        throw new FileError('Invalid file: Missing URI');
      }

      if (Platform.OS === 'web') {
        try {
          const response = await fetch(file.uri);
          if (!response.ok) throw new FileError('Failed to fetch file');
          const blob = await response.blob();
          formData.append('resume', blob, file.name);
        } catch (error) {
          throw new FileError('Failed to process file for web upload');
        }
      } else {
        const fileInfo = await FileSystem.getInfoAsync(file.uri);
        if (!fileInfo.exists) {
          throw new FileError('File does not exist');
        }

        formData.append('resume', {
          uri: fileInfo.uri,
          type: file.mimeType || 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
          name: file.name,
        } as any);
      }

      if (additionalData) {
        Object.entries(additionalData).forEach(([key, value]) => {
          formData.append(key, typeof value === 'string' ? value : JSON.stringify(value));
        });
      }

      return formData;
    } catch (error) {
      if (error instanceof FileError) throw error;
      throw new FileError('Failed to create form data');
    }
  },
};

================
File: client/src/types/message.ts
================
import type { DocumentPickerAsset } from 'expo-document-picker';

export interface Message {
  id: string;
  text: string;
  sender: 'AI' | 'Me';
  type?: 'file' | 'confirmation';
  file?: {
    name: string;
    size?: number;
    type?: string;
    path?: string;
  };
  structuredText?: string;
}

export interface FileAttachment {
  name: string;
  size?: number;
  type?: string;
  path?: string;
  uri?: string;
  mimeType?: string;
}

export interface FileUploadResponse {
  success: boolean;
  path: string;
  message?: string;
}

export interface JobStructureResponse {
  success: boolean;
  structuredText: string;
  message?: string;
}

export interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

export type MessageHandler = (text: string) => Promise<void> | void;
export type FileHandler = (file: DocumentPickerAsset) => Promise<void>;
export type ErrorHandler = (error: string) => void;
export type ConfirmationHandler = (confirm: boolean, structuredText?: string) => void;

// Navigation types
export type RootStackParamList = {
  Home: undefined;
  Chat: undefined;
};

================
File: client/src/utils/errorHandler.ts
================
export class AppError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = 'AppError';
  }
}

export const handleError = (error: unknown): string => {
  if (error instanceof AppError) {
    return error.message;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return 'An unexpected error occurred';
};

================
File: client/src/app.json
================
{
  "expo": {
    "name": "tradie_resume_builder",
    "slug": "snack-8d455639-0986-42dc-ae64-99055228f569",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "light",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#ffffff"
    },
    "ios": {
      "supportsTablet": true 
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#ffffff"
      }
    },
    "web": {
      "favicon": "./assets/favicon.png"
    }
  }
}

================
File: client/src/App.tsx
================
import React from 'react';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import StackNavigator from './navigation/StackNavigator';

export default function App() {
  return (
    <SafeAreaProvider>
      <StackNavigator />
    </SafeAreaProvider>
  );
}

================
File: client/.gitignore
================
# Learn more https://docs.github.com/en/get-started/getting-started-with-git/ignoring-files

# dependencies
node_modules/

# Expo
.expo/
dist/
web-build/

# Native
*.orig.*
*.jks
*.p8
*.p12
*.key
*.mobileprovision

# Metro
.metro-health-check*

# debug
npm-debug.*
yarn-debug.*
yarn-error.*

# macOS
.DS_Store
*.pem

# local env files
.env*.local

# typescript
*.tsbuildinfo

================
File: client/babel.config.js
================
module.exports = function(api) {
  api.cache(true);
  return {
    presets: ["babel-preset-expo"],
    plugins: [
      "nativewind/babel",
      [
        "module-resolver",
        {
          root: ["./src"],
          alias: {
            "@": "./src"
          }
        }
      ]
    ]
  };
};

================
File: client/package.json
================
{
  "main": "expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "@expo/metro-runtime": "~3.2.3",
    "@expo/vector-icons": "^14.0.2",
    "@react-navigation/native": "^6.1.8",
    "@react-navigation/stack": "^6.4.1",
    "axios": "*",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "expo": "~51.0.28",
    "expo-document-picker": "~12.0.2",
    "expo-status-bar": "~1.12.1",
    "nativewind": "^4.1.23",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-native": "0.74.5",
    "react-native-gesture-handler": "~2.16.1",
    "react-native-paper": "4.9.2",
    "react-native-safe-area-context": "^4.10.5",
    "react-native-screens": "3.31.1",
    "react-native-web": "~0.19.10",
    "tailwindcss": "^3.4.14"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "^18.3.12",
    "@types/react-native": "^0.73.0",
    "eslint": "^9.14.0",
    "prettier": "^3.3.3",
    "typescript": "^5.6.3"
  },
  "private": true
}

================
File: client/tailwind.config.js
================
echo 'module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: "#f4511e",
          dark: "#d84315",
          light: "#ff7043"
        }
      }
    }
  },
  plugins: []
}' > tailwind.config.js

================
File: client/tsconfig.json
================
echo '{
  "compilerOptions": {
    "target": "es2016",
    "module": "esnext",
    "lib": ["es2017", "dom"],
    "jsx": "react-native",
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },
    "allowJs": true,
    "strict": true,
    "noImplicitAny": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true
  },
  "include": ["src"],
  "exclude": ["node_modules"]
}' > tsconfig.json

================
File: server/config/constants.js
================
/**
 * API Endpoints configuration
 * Contains all the API endpoint paths used in the application
 */
export const API_ENDPOINTS = {
  UPLOAD_RESUME: '/api/upload-resume',
  STRUCTURE_JOB: '/api/structure-job-description',
  UPDATE_RESUME: '/api/update-resume'
};

/**
 * CORS Configuration
 * Allowed origins for CORS requests
 */
export const ALLOWED_ORIGINS = ['http://localhost:8081', 'http://localhost:5001'];

/**
 * File type constants
 * Supported file types and their MIME types
 */
export const FILE_TYPES = {
  DOCX: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
};

/**
 * File upload configurations
 */
export const UPLOAD_CONFIG = {
  MAX_FILE_SIZE: 5 * 1024 * 1024, // 5MB in bytes
  ALLOWED_FILE_TYPES: [FILE_TYPES.DOCX],
  UPLOAD_DIR: 'uploads'
};

/**
 * Error messages used throughout the application
 */
export const ERROR_MESSAGES = {
  // File upload related errors
  INVALID_FILE_TYPE: 'Invalid file type. Only DOCX files are allowed.',
  FILE_TOO_LARGE: 'File size exceeds the maximum limit of 5MB.',
  NO_FILE_RECEIVED: 'No file was received.',
  UPLOAD_FAILED: 'File upload failed.',
  FILE_WRITE_ERROR: 'Error saving file.',
  FILE_DELETE_ERROR: 'Error deleting file.',
  
  // Job description related errors
  MISSING_JOB_DESCRIPTION: 'Job description is required.',
  INVALID_JOB_DESCRIPTION: 'Invalid job description format.',
  JOB_DESCRIPTION_TOO_SHORT: 'Job description is too short.',
  PROCESSING_FAILED: 'Failed to process job description.',
  
  // Resume related errors
  NO_RESUME_UPLOADED: 'No resume has been uploaded.',
  MISSING_JOB_DETAILS: 'Structured job details are required.',
  INVALID_JOB_DETAILS: 'Invalid job details format.',
  UPDATE_FAILED: 'Failed to update resume.',
  EXPERIENCE_SECTION_NOT_FOUND: 'Could not find experience section in resume.',
  TEMPLATE_NOT_FOUND: 'Could not find job entry template in resume.',
  INVALID_RESUME_FORMAT: 'Invalid resume format or structure.',
  
  // OpenAI related errors
  AI_PROCESSING_ERROR: 'Error processing with AI service.',
  AI_RESPONSE_ERROR: 'Invalid response from AI service.',
  
  // Server errors
  INTERNAL_SERVER_ERROR: 'Internal server error occurred.',
  SERVICE_UNAVAILABLE: 'Service temporarily unavailable.'
};

/**
 * Success messages used throughout the application
 */
export const SUCCESS_MESSAGES = {
  FILE_UPLOADED: 'File uploaded successfully.',
  RESUME_UPDATED: 'Resume updated successfully.',
  JOB_STRUCTURED: 'Job description structured successfully.'
};

/**
 * OpenAI configuration
 */
export const OPENAI_CONFIG = {
  MODEL: 'gpt-3.5-turbo',
  MAX_TOKENS: 300,
  TEMPERATURE: 0.5
};

/**
 * Validation constants
 */
export const VALIDATION = {
  MIN_JOB_DESCRIPTION_LENGTH: 10,
  MIN_JOB_DETAILS_LINES: 3,
  MAX_BULLET_POINTS: 5
};

/**
 * HTTP Status codes
 */
export const HTTP_STATUS = {
  OK: 200,
  CREATED: 201,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  INTERNAL_SERVER: 500,
  SERVICE_UNAVAILABLE: 503
};

/**
 * Application routes
 */
export const ROUTES = {
  API: {
    PREFIX: '/api',
    RESUME: {
      UPLOAD: '/upload-resume',
      UPDATE: '/update-resume'
    },
    JOB: {
      STRUCTURE: '/structure-job-description'
    }
  }
};

/**
 * Logging levels
 */
export const LOG_LEVELS = {
  ERROR: 'ERROR',
  WARN: 'WARN',
  INFO: 'INFO',
  DEBUG: 'DEBUG'
};

================
File: server/config/openai.js
================
// 1. config/openai.js
import OpenAI from 'openai/index.mjs';
import dotenv from 'dotenv';

dotenv.config();

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

export default openai;

================
File: server/middleware/errorHandler.js
================
import { AppError } from '../utils/errors.js';

const errorHandler = (err, req, res, next) => {
  console.error(err.stack);

  if (err instanceof AppError) {
    return res.status(err.statusCode).json({
      success: false,
      error: err.message,
      stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }

  // Handle other types of errors
  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  res.status(statusCode).json({
    success: false,
    error: message,
    stack: process.env.NODE_ENV === 'development' ? err.stack : undefined
  });
};

export default errorHandler;

================
File: server/middleware/upload.js
================
// 2. middleware/upload.js
import busboy from 'busboy';
import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import { dirname } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const uploadsDir = path.join(__dirname, '../uploads');

const uploadMiddleware = (req, res, next) => {
  if (!fs.existsSync(uploadsDir)) {
    fs.mkdirSync(uploadsDir);
  }

  const bb = busboy({ headers: req.headers });
  let saveToPath = '';
  let fileReceived = false;

  bb.on('file', (name, file, info) => {
    fileReceived = true;
    const { filename, mimeType } = info;

    if (!mimeType.includes('openxmlformats-officedocument.wordprocessingml.document')) {
      return next(new Error('Invalid file type. Only DOCX files are allowed.'));
    }

    const saveTo = path.join(uploadsDir, filename);
    saveToPath = saveTo;

    const writeStream = fs.createWriteStream(saveTo);
    file.pipe(writeStream);

    writeStream.on('finish', () => {
      req.file = {
        path: saveTo,
        filename: filename
      };
      next();
    });

    writeStream.on('error', next);
  });

  bb.on('error', next);
  bb.on('finish', () => {
    if (!fileReceived) {
      next(new Error('No file was received'));
    }
  });

  req.pipe(bb);
};

export default uploadMiddleware;

================
File: server/middleware/validate.js
================
// middleware/validate.js
import { check, validationResult } from 'express-validator';
import { AppError } from '../utils/errors.js';
import { VALIDATION } from '../config/constants.js';

export const validateJobDescription = [
  check('description')
    .trim()
    .notEmpty()
    .withMessage('Job description is required')
    .isLength({ min: VALIDATION.MIN_JOB_DESCRIPTION_LENGTH })
    .withMessage(`Job description must be at least ${VALIDATION.MIN_JOB_DESCRIPTION_LENGTH} characters long`)
    .escape(),
  
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      throw new AppError(errors.array()[0].msg, 400);
    }
    next();
  }
];

export const validateResumeUpdate = [
  check('structuredJobDetails')
    .trim()
    .notEmpty()
    .withMessage('Structured job details are required')
    .custom((value) => {
      const lines = value.split('\n');
      if (lines.length < VALIDATION.MIN_JOB_DETAILS_LINES) {
        throw new Error('Invalid job details format');
      }
      if (lines.filter(line => line.trim().startsWith('•')).length > VALIDATION.MAX_BULLET_POINTS) {
        throw new Error(`Maximum ${VALIDATION.MAX_BULLET_POINTS} bullet points allowed`);
      }
      return true;
    }),
    
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      throw new AppError(errors.array()[0].msg, 400);
    }
    next();
  }
];

================
File: server/routes/jobRoutes.js
================
// 6. routes/jobRoutes.js
import express from 'express';
import asyncHandler from '../utils/asyncHandler.js';
import JobService from '../services/jobService.js';
import { AppError } from '../utils/errors.js';
import { validateJobDescription } from '../middleware/validate.js';

const router = express.Router();

router.post('/structure-job-description', validateJobDescription, asyncHandler(async (req, res) => {
  if (!req.body?.description) {
    throw new AppError('Job description is required', 400);
  }

  const structuredText = await JobService.structureJobDescription(req.body.description);
  res.json({ structuredText });
}));

export default router;

================
File: server/routes/resumeRoutes.js
================
import express from 'express';
import uploadMiddleware from '../middleware/upload.js';
import ResumeService from '../services/resumeService.js'; 
import asyncHandler from '../utils/asyncHandler.js';
import { validateResumeUpdate } from '../middleware/validate.js';

const router = express.Router();

router.post('/upload-resume', uploadMiddleware, asyncHandler(async (req, res) => {
  res.json({
    message: 'File uploaded successfully',
    path: req.file.path
  });
}));

router.post('/update-resume', uploadMiddleware, validateResumeUpdate, asyncHandler(async (req, res) => {
  const { structuredJobDetails } = req.body;
  if (!structuredJobDetails) {
    throw new Error('Structured job details are required');
  }

  const updatedResumePath = await ResumeService.processResume(  // Updated reference
    req.file.path,
    structuredJobDetails
  );

  res.json({
    success: true,
    message: 'Resume updated successfully',
    path: updatedResumePath
  });
}));

export default router;

================
File: server/services/jobService.js
================
// 5. services/jobService.js
import openai from '../config/openai.js';

class JobService {
  async structureJobDescription(description) {
    const prompt = `
      Convert the following unstructured job description into a professional, well-articulated
      resume section.
      Use the exact format shown in the example below:
      Example:
      Christies People (Labourer)
      NOV 2023 - JUN 2024, Sydney
      • Operated power tools safely and effectively to complete tasks in a timely manner.
      • Assisted tradespeople as required, ensuring smooth project flow.
      • Managed site opening and closing, ensuring all protocols were followed.
      • Controlled site traffic when necessary, maintaining safe access and flow.
      Rules:
      1. Use the exact format shown above.
      2. Start each bullet point with a strong action verb in past tense.
      3. Focus on specific achievements, impacts, and quantifiable results where possible.
      4. Use professional language suitable for a construction industry resume.
      5. Limit to 4-5 bullet points maximum.
      6. Ensure all information is accurate based on the input provided.
      Unstructured Input: ${description}
    `;

    const response = await openai.chat.completions.create({
      model: "gpt-3.5-turbo",
      messages: [{ role: "user", content: prompt }],
      temperature: 0.5,
      max_tokens: 300,
    });

    let structuredText = response.choices[0].message.content.trim();
    structuredText = this.formatStructuredText(structuredText);
    
    return structuredText;
  }

  formatStructuredText(text) {
    return text
      .replace(/•/g, '- ')
      .replace(/(\d{4}) - (\d{4})/g, '$1-$2')
      .replace(/- (.+?)(?=\n|$)/g, (match, p1) => {
        return `- ${p1.charAt(0).toUpperCase() + p1.slice(1)}${p1.endsWith('.') ? '' : '.'}`;
      });
  }
}

export default new JobService();

================
File: server/services/logService.js
================
class LogService {
  constructor() {
    this.levels = {
      ERROR: 'ERROR',
      WARN: 'WARN',
      INFO: 'INFO',
      DEBUG: 'DEBUG'
    };
  }

  formatMessage(level, message, data = {}) {
    return {
      timestamp: new Date().toISOString(),
      level,
      message,
      ...data
    };
  }

  error(message, error = null) {
    const logData = this.formatMessage(this.levels.ERROR, message, {
      error: error ? {
        message: error.message,
        stack: error.stack
      } : null
    });
    console.error(JSON.stringify(logData));
  }

  warn(message, data = {}) {
    const logData = this.formatMessage(this.levels.WARN, message, data);
    console.warn(JSON.stringify(logData));
  }

  info(message, data = {}) {
    const logData = this.formatMessage(this.levels.INFO, message, data);
    console.log(JSON.stringify(logData));
  }

  debug(message, data = {}) {
    if (process.env.NODE_ENV === 'development') {
      const logData = this.formatMessage(this.levels.DEBUG, message, data);
      console.log(JSON.stringify(logData));
    }
  }
}

export default new LogService();

================
File: server/services/resumeService.js
================
import JSZip from 'jszip';
import fs from 'fs/promises';
import { DOMParser, XMLSerializer } from 'xmldom';
import path from 'path';
import { 
  ERROR_MESSAGES, 
  UPLOAD_CONFIG,
  SUCCESS_MESSAGES 
} from '../config/constants.js';
import logger from './logService.js';

class ResumeService {
  /**
   * Main method to process resume
   * @param {string} filePath - File path
   * @param {string} structuredJobDetails - Job details
   * @returns {Promise<string>} Updated file path
   */
  async processResume(filePath, structuredJobDetails) {
    try {
      logger.info('Starting resume processing', { filePath });
      
      // Read and load the document
      const buffer = await fs.readFile(filePath);
      const zip = new JSZip();
      await zip.loadAsync(buffer);

      // Load all document parts
      const parts = await this.loadDocumentParts(zip);
      
      // Process the document
      const processedDoc = await this.processDocument(
        parts.documentXml,
        parts.stylesXml,
        parts.numbersXml,
        parts.themeXml,
        structuredJobDetails
      );

      // Update document parts
      await this.updateDocumentParts(
        zip, 
        processedDoc, 
        parts.docRels,
        parts.fontTable,
        parts.settings
      );

      // Generate and save the updated document
      const updatedFilePath = await this.generateUpdatedDocument(zip, filePath);

      logger.info('Resume processing completed successfully');
      return updatedFilePath;
    } catch (error) {
      logger.error('Error processing resume:', error);
      throw new Error(`Resume processing failed: ${error.message}`);
    }
  }

  /**
   * Loads and parses all necessary document parts from a DOCX file
   */
  async loadDocumentParts(zip) {
    try {
      logger.info('Loading document parts');
      
      // Load required document.xml first
      const documentXml = await zip.file('word/document.xml')?.async('string');
      if (!documentXml) {
        throw new Error(ERROR_MESSAGES.INVALID_RESUME_FORMAT);
      }

      // Load optional parts with null fallback
      const [stylesXml, numbersXml, themeXml, docRels, fontTable, settings] = await Promise.all([
        zip.file('word/styles.xml')?.async('string').catch(() => null),
        zip.file('word/numbering.xml')?.async('string').catch(() => null),
        zip.file('word/theme/theme1.xml')?.async('string').catch(() => null),
        zip.file('word/_rels/document.xml.rels')?.async('string').catch(() => null),
        zip.file('word/fontTable.xml')?.async('string').catch(() => null),
        zip.file('word/settings.xml')?.async('string').catch(() => null)
      ]);

      return {
        documentXml,
        stylesXml,
        numbersXml,
        themeXml,
        docRels,
        fontTable,
        settings
      };
    } catch (error) {
      logger.error('Error loading document parts:', error);
      throw new Error(`Failed to load document components: ${error.message}`);
    }
  }

  /**
   * Process document and add new job entry
   */
  async processDocument(documentXml, stylesXml, numbersXml, themeXml, structuredJobDetails) {
    logger.info('Processing document content');
    const parser = new DOMParser();
    const doc = parser.parseFromString(documentXml, 'text/xml');
    
    // Parse optional components
    const styles = stylesXml ? parser.parseFromString(stylesXml, 'text/xml') : null;
    const numbering = numbersXml ? parser.parseFromString(numbersXml, 'text/xml') : null;
    const theme = themeXml ? parser.parseFromString(themeXml, 'text/xml') : null;

    // Parse job details
    const jobLines = structuredJobDetails.split('\n');
    if (jobLines.length < 2) {
      throw new Error(ERROR_MESSAGES.INVALID_JOB_DETAILS);
    }

    const title = jobLines[0];
    const period = jobLines[1];
    const bullets = jobLines.slice(2)
      .filter(point => point.trim().startsWith('-'))
      .map(point => point.trim().substring(2));

    // Find and validate experience section
    const experienceSection = this.findExperienceSection(doc);
    if (!experienceSection) {
      throw new Error(ERROR_MESSAGES.EXPERIENCE_SECTION_NOT_FOUND);
    }

    // Get and validate template
    const template = this.getJobEntryTemplate(experienceSection);
    if (!template) {
      throw new Error(ERROR_MESSAGES.TEMPLATE_NOT_FOUND);
    }

    // Create new job entry
    const newJobEntry = this.createJobEntry(doc, template, {
      title,
      period,
      bullets
    });

    // Find insertion point and insert new entry
    const insertionPoint = this.findInsertionPoint(experienceSection);
    if (!insertionPoint) {
      throw new Error(ERROR_MESSAGES.TEMPLATE_NOT_FOUND);
    }

    insertionPoint.parentNode.insertBefore(newJobEntry, insertionPoint);

    return {
      document: doc,
      styles,
      numbering,
      theme
    };
  }

  /**
   * Find the experience section in the document
   */
  findExperienceSection(doc) {
    const paragraphs = doc.getElementsByTagName('w:p');
    for (let i = 0; i < paragraphs.length; i++) {
      const text = this.getParagraphText(paragraphs[i]).toLowerCase();
      if (text.includes('experience') || text.includes('employment history')) {
        return paragraphs[i].parentNode;
      }
    }
    return null;
  }
  /**
   * Get template for job entry
   */
  getJobEntryTemplate(section) {
    const paragraphs = section.getElementsByTagName('w:p');
    for (let i = 0; i < paragraphs.length; i++) {
      const text = this.getParagraphText(paragraphs[i]);
      if (text.includes('(') && text.includes(')') && /\d{4}/.test(text)) {
        return {
          title: paragraphs[i],
          period: paragraphs[i + 1] || paragraphs[i],
          bullet: this.findBulletTemplate(paragraphs, i + 2)
        };
      }
    }
    return null;
  }

  /**
   * Find bullet template from existing entries
   */
  findBulletTemplate(paragraphs, startIndex) {
    for (let i = startIndex; i < Math.min(startIndex + 5, paragraphs.length); i++) {
      const text = this.getParagraphText(paragraphs[i]);
      if (text.trim().startsWith('•') || text.trim().startsWith('-')) {
        return paragraphs[i];
      }
    }
    return paragraphs[startIndex];
  }

  /**
   * Create a new job entry based on template
   */
  createJobEntry(doc, template, jobData) {
    logger.info('Creating new job entry');
    const fragment = doc.createDocumentFragment();

    // Title paragraph
    const titlePara = this.cloneNodeWithStyles(template.title);
    this.setTextContentPreservingStyle(titlePara, jobData.title);
    fragment.appendChild(titlePara);

    // Period paragraph
    const periodPara = this.cloneNodeWithStyles(template.period);
    this.setTextContentPreservingStyle(periodPara, jobData.period);
    fragment.appendChild(periodPara);

    // Bullet points
    jobData.bullets.forEach(bullet => {
      const bulletPara = this.cloneNodeWithStyles(template.bullet);
      this.setTextContentPreservingStyle(bulletPara, `• ${bullet}`);
      fragment.appendChild(bulletPara);
    });

    // Add spacing paragraph
    const spacingPara = this.cloneNodeWithStyles(template.title);
    this.setTextContentPreservingStyle(spacingPara, '');
    fragment.appendChild(spacingPara);

    return fragment;
  }

  /**
   * Clone node while preserving styles
   */
  cloneNodeWithStyles(node) {
    const clone = node.cloneNode(true);
    
    const pPr = node.getElementsByTagName('w:pPr')[0];
    if (pPr) {
      const clonePPr = clone.getElementsByTagName('w:pPr')[0] || 
                       clone.ownerDocument.createElement('w:pPr');
      
      Array.from(pPr.childNodes).forEach(child => {
        clonePPr.appendChild(child.cloneNode(true));
      });
      
      if (clone.firstChild) {
        clone.insertBefore(clonePPr, clone.firstChild);
      } else {
        clone.appendChild(clonePPr);
      }
    }
    
    return clone;
  }

  /**
   * Set text content while preserving style
   */
  setTextContentPreservingStyle(paragraph, text) {
    const runs = paragraph.getElementsByTagName('w:r');
    if (runs.length === 0) {
      return this.createNewFormattedRun(paragraph, text);
    }

    const firstRun = runs[0];
    const rPr = firstRun.getElementsByTagName('w:rPr')[0];

    const pPr = paragraph.getElementsByTagName('w:pPr')[0];
    while (paragraph.firstChild) {
      paragraph.removeChild(paragraph.firstChild);
    }
    if (pPr) {
      paragraph.appendChild(pPr.cloneNode(true));
    }

    const newRun = this.createRunWithFormatting(paragraph.ownerDocument, text, rPr);
    paragraph.appendChild(newRun);
  }

  /**
   * Create run with formatting
   */
  createRunWithFormatting(doc, text, rPr) {
    const run = doc.createElement('w:r');
    
    if (rPr) {
      run.appendChild(rPr.cloneNode(true));
    }

    const textElement = doc.createElement('w:t');
    if (text.startsWith(' ') || text.endsWith(' ')) {
      textElement.setAttribute('xml:space', 'preserve');
    }
    textElement.textContent = text;
    run.appendChild(textElement);

    return run;
  }

  /**
   * Create new formatted run
   */
  createNewFormattedRun(paragraph, text) {
    const doc = paragraph.ownerDocument;
    let pPr = paragraph.getElementsByTagName('w:pPr')[0];
    if (!pPr) {
      pPr = doc.createElement('w:pPr');
      paragraph.insertBefore(pPr, paragraph.firstChild);
    }

    const run = this.createRunWithFormatting(doc, text, null);
    paragraph.appendChild(run);
  }

  /**
   * Find insertion point for new entry
   */
  findInsertionPoint(section) {
    const paragraphs = section.getElementsByTagName('w:p');
    for (let i = 0; i < paragraphs.length; i++) {
      const text = this.getParagraphText(paragraphs[i]).toLowerCase();
      if (text.includes('experience') || text.includes('employment history')) {
        return paragraphs[i + 1] || paragraphs[i];
      }
    }
    return paragraphs[0];
  }

  /**
   * Get text content from paragraph
   */
  getParagraphText(paragraph) {
    const texts = paragraph.getElementsByTagName('w:t');
    return Array.from(texts).map(t => t.textContent).join('');
  }

  /**
   * Update document parts in zip
   */
  async updateDocumentParts(zip, processedDoc, docRels, fontTable, settings) {
    logger.info('Updating document parts');
    const serializer = new XMLSerializer();
    
    zip.file('word/document.xml', serializer.serializeToString(processedDoc.document));
    
    if (processedDoc.styles) {
      zip.file('word/styles.xml', serializer.serializeToString(processedDoc.styles));
    }
    if (processedDoc.numbering) {
      zip.file('word/numbering.xml', serializer.serializeToString(processedDoc.numbering));
    }
    if (processedDoc.theme) {
      zip.file('word/theme/theme1.xml', serializer.serializeToString(processedDoc.theme));
    }
    if (docRels) {
      zip.file('word/_rels/document.xml.rels', docRels);
    }
    if (fontTable) {
      zip.file('word/fontTable.xml', fontTable);
    }
    if (settings) {
      zip.file('word/settings.xml', settings);
    }
  }

  /**
   * Generate updated document
   */
  async generateUpdatedDocument(zip, originalFilePath) {
    logger.info('Generating updated document');
    const updatedBuffer = await zip.generateAsync({ type: 'nodebuffer' });
    const parsedPath = path.parse(originalFilePath);
    const updatedFilePath = path.join(
      parsedPath.dir,
      `${parsedPath.name}_updated${parsedPath.ext}`
    );
    await fs.writeFile(updatedFilePath, updatedBuffer);
    return updatedFilePath;
  }
}

export default new ResumeService();

================
File: server/utils/asyncHandler.js
================
// 4. utils/asyncHandler.js
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

export default asyncHandler;

================
File: server/utils/error.js
================
export class AppError extends Error {
  constructor(message, statusCode = 500) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

================
File: server/.gitignore
================
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

================
File: server/package.json
================
{
  "name": "nodejs",
  "version": "1.0.0",
  "description": "",
  "type": "module",
  "main": "server.js",  
  "scripts": {
    "start": "node server.js",  
    "dev": "nodemon server.js"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "openai": "^4.0.0",
    "busboy": "^1.6.0",
    "jszip": "^3.10.1",
    "xmldom": "^0.6.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}

================
File: server/server.js
================
import express from 'express';
import cors from 'cors';
import dotenv from 'dotenv';
import resumeRoutes from './routes/resumeRoutes.js';
import jobRoutes from './routes/jobRoutes.js';
import errorHandler from './middleware/errorHandler.js';

dotenv.config();

const app = express();

// Middleware
app.use(express.json());
app.use(cors({
  origin: ['http://localhost:8081', 'http://localhost:5001'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'Cache-Control', 'Pragma'],
  credentials: true
}));

// Routes
app.use('/api', resumeRoutes);
app.use('/api', jobRoutes);

// Error handling
app.use(errorHandler);

const PORT = process.env.PORT || 5001;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

export default app;

================
File: README.md
================
# Sample Snack app

Open the `App.js` file to start writing some code. You can preview the changes directly on your phone or tablet by scanning the **QR code** or use the iOS or Android emulators. When you're done, click **Save** and share the link!

When you're ready to see everything that Expo provides (or if you want to use your own editor) you can **Download** your project and use it with [expo cli](https://docs.expo.dev/get-started/installation/#expo-cli)).

All projects created in Snack are publicly available, so you can easily share the link to this project via link, or embed it on a web page with the `<>` button.

If you're having problems, you can tweet to us [@expo](https://twitter.com/expo) or ask in our [forums](https://forums.expo.dev/c/expo-dev-tools/61) or [Discord](https://chat.expo.dev/).

Snack is Open Source. You can find the code on the [GitHub repo](https://github.com/expo/snack).
